# 装饰设计模式
对一组对象的功能进行增强时，就可以使用该模式进行问题的解决。  
装饰和继承都能实现一样的特点：进行功能的扩展增强。有什么区别？  
假设有一个继承体系：  
Writer  
	|--TextWriter: 用于操作文本  
	|--MediaWriter: 用于操作媒体  
想要对操作的动作进行效率的提高。按照面向对象，可以通过继承对具体的操作进行功能的扩展，而效率提高需要加入缓冲技术。  
Writer  
	|--TextWriter:用于操作文本  
		|--BufferTextWriter:加入了缓冲技术的操作文本的对象(操作+缓冲)  
	|--MediaWriter：用于操作媒体。  
		|--BufferMediaWriter:操作+缓冲  
到这里就哦了，但是这样做好像并不理想。如果这个体系进行功能扩展，又多了一些流对象，那么这个流要提高效率，是不是也要产生子类呢？是。  
这时就会发现只为提高功能而进行的继承，会导致继承体系越来越臃肿，不够灵活。   
重新思考这个问题？  
既然不同的流加入的都是同一种技术--缓冲，上面的方法是让缓冲和每一个具体的对象相结合。那就可以将缓冲进行单独的封装，哪个对象需要缓冲就将哪个对象和缓冲关联(通过构造函数传入需要被关联的对象)  
class Buffer{  
	Buffer(TextWriter w)  
	{}  
	Buffer(MediaWirter w)  
	{}  
}  
可以对代码改进，采用多态的方法：  
class BufferWriter extends Writer{//多态，可以操作父类及其子类  
	BufferWriter(Writer w)  
	{}  
}   
Writer  
	|--TextWriter:用于操作文本  
	|--MediaWriter：用于操作媒体。  
	|--BufferWriter:用于提高Writer效率。  
装饰比继承灵活。IO流的缓冲区就是用这种思想创建出来的。这种思想可以用到其他的Java体系上。  
注意：装饰类和被装饰类都必须所属同一个接口或者父类。  
